name: Deploy to Prod Server

on:
  push:
    branches:
      - production  # ðŸš€ Runs only when merged to `production`

permissions:
  contents: write

jobs:
  versioning:
    runs-on: ubuntu-latest
    outputs:
      NEW_VERSION: ${{ steps.new_version.outputs.VERSION }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Ensures all tags are fetched

      # âœ… Step 1: Install Node.js (Required for semver)
      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 22

      # âœ… Step 2: Install pnpm (Needed for package management)
      - name: Install pnpm
        run: npm install -g pnpm

      # âœ… Step 3: Install semver
      - name: Install semver
        run: pnpm add -g semver  # âœ… Uses pnpm instead of npm

      # âœ… Step 4: Get Latest Git Tag
      - name: Get Latest Git Tag
        id: get_version
        run: |
          LATEST_TAG=$(git tag --sort=-v:refname | grep 'prod-' | head -n 1 || echo "prod-0.0.0")
          echo "LATEST_TAG=$LATEST_TAG"
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

      # âœ… Step 5: Determine New Version
      - name: Determine New Version (Commit Message-Based)
        id: new_version
        run: |
          VERSION_TYPE="patch"  # Default bump: PATCH

          # Check commit messages for version bump hints
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -q "#major"; then VERSION_TYPE="major"; fi
          if echo "$COMMIT_MSG" | grep -q "#minor"; then VERSION_TYPE="minor"; fi

          # Use semver to generate new version
          NEW_VERSION=$(pnpm exec semver -i $VERSION_TYPE ${LATEST_TAG#prod-})
          FULL_VERSION="prod-${NEW_VERSION}"

          echo "VERSION=$FULL_VERSION" >> $GITHUB_ENV
          echo "::set-output name=VERSION::$FULL_VERSION"
          echo "New version: $FULL_VERSION"

      # âœ… Step 6: Create Git Tag & Push
      - name: Create Git Tag & Push
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          git tag ${{ env.VERSION }}
          git push origin ${{ env.VERSION }}

  build-and-push:
    runs-on: ubuntu-latest
    needs: versioning
    env:
      IMAGE_TAG: ${{ needs.versioning.outputs.NEW_VERSION }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Docker Images
        run: |
          docker build -t faithfulconnects/ws-server:${{ env.IMAGE_TAG }} ./apps/ws-server
          docker build -t faithfulconnects/http-server:${{ env.IMAGE_TAG }} ./apps/http-server
          docker build -t faithfulconnects/web:${{ env.IMAGE_TAG }} ./apps/web

          docker push faithfulconnects/ws-server:${{ env.IMAGE_TAG }}
          docker push faithfulconnects/http-server:${{ env.IMAGE_TAG }}
          docker push faithfulconnects/web:${{ env.IMAGE_TAG }}

  deploy-production:
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      IMAGE_TAG: ${{ needs.versioning.outputs.NEW_VERSION }}

    steps:
      - name: Deploy to Production Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_PROD_HOST }}
          username: ${{ secrets.SSH_PROD_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "ðŸ”¹ Checking & Installing Dependencies..."

            # Ensure system packages are up to date
            sudo apt update && sudo apt install -y curl jq

            # Install Docker if missing
            if ! command -v docker &> /dev/null; then
              echo "ðŸ”¹ Installing Docker..."
              curl -fsSL https://get.docker.com | sh
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker $USER
            else
              echo "âœ… Docker is already installed."
            fi

            # Install Docker Compose if missing
            if ! command -v docker-compose &> /dev/null; then
              echo "ðŸ”¹ Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "âœ… Docker Compose is already installed."
            fi

            # Verify Installation
            docker --version
            docker-compose --version

            echo "ðŸ”¹ Pulling latest Docker images..."
            docker pull faithfulconnects/ws-server:${{ env.IMAGE_TAG }}
            docker pull faithfulconnects/http-server:${{ env.IMAGE_TAG }}
            docker pull faithfulconnects/web:${{ env.IMAGE_TAG }}

            echo "ðŸ”¹ Stopping existing containers..."
            docker-compose down || true

            echo "ðŸ”¹ Writing updated docker-compose.yml..."
            cat > docker-compose.yml <<EOL
            version: "3.8"
            services:
              ws-server:
                image: faithfulconnects/ws-server:${{ env.IMAGE_TAG }}
                env_file:
                  - .env
                ports:
                  - '3001:3001'

              http-server:
                image: faithfulconnects/http-server:${{ env.IMAGE_TAG }}
                env_file:
                  - .env
                ports:
                  - '3002:3002'

              web:
                image: faithfulconnects/web:${{ env.IMAGE_TAG }}
                ports:
                  - '3000:3000'

              nginx:
                image: nginx:latest
                volumes:
                  - ./nginx/nginx.conf:/etc/nginx/nginx.conf
                  - /etc/letsencrypt:/etc/letsencrypt
                  - /var/lib/letsencrypt:/var/lib/letsencrypt
                ports:
                  - '80:80'
                  - '443:443'
                depends_on:
                  - ws-server
                  - http-server
                  - web

            networks:
              fcn-network:
                driver: bridge
            EOL

            echo "ðŸ”¹ Creating .env file..."
            cat > .env <<EOL
            MONGO_URI=${{ secrets.MONGO_URI }}
            SUPABASE_URL=${{ secrets.SUPABASE_URL }}
            SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
            EOL

            echo "ðŸ”¹ Restarting services..."
            docker-compose up -d --force-recreate

            echo "âœ… Deployment to AWS Production completed!"

            # ðŸ”¥ SECURE CLEANUP: Remove the .env file after use
            echo "ðŸ”¹ Removing .env file for security..."
            rm -f .env
            echo "âœ… .env file deleted successfully."
